#!/usr/bin/env node
/**
 * Consonant Design Tokens to CSS Converter
 * 
 * Converts design token JSON files (Desktop, Tablet, Mobile) 
 * into CSS custom properties with responsive media queries.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Breakpoint configurations
const BREAKPOINTS = {
  desktop: { file: 'Desktop.tokens.json', minWidth: 900 },
  tablet: { file: 'Tablet.tokens.json', minWidth: 600, maxWidth: 899 },
  mobile: { file: 'Mobile.tokens.json', maxWidth: 599 }
};

/**
 * Recursively flatten nested token objects into CSS custom property format
 * Example: { Size: { Column: { width: 500 } } } => "--size-column-width"
 */
function flattenTokens(obj, prefix = '', result = {}) {
  for (const key in obj) {
    if (key === '$extensions' || key === '$type' || key === '$description') {
      continue;
    }

    const value = obj[key];
    const newKey = prefix ? `${prefix}-${key}` : key;

    if (value && typeof value === 'object' && value.$value !== undefined) {
      // This is a token with a value
      const cssVarName = `--${convertToCssVarName(newKey)}`;
      result[cssVarName] = formatValue(value.$value, value.$type);
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      // Recurse into nested objects
      flattenTokens(value, newKey, result);
    }
  }
  return result;
}

/**
 * Convert token path to CSS custom property name
 * Example: "Size/Column/width" => "size-column-width"
 */
function convertToCssVarName(str) {
  return str
    .replace(/[\/\s]+/g, '-')
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '');
}

/**
 * Format token value based on type
 */
function formatValue(value, type) {
  if (type === 'number') {
    return `${value}px`;
  }
  if (type === 'color') {
    return value;
  }
  if (typeof value === 'string') {
    // Handle font references or other string values
    if (value.startsWith('{') && value.endsWith('}')) {
      // This is a reference to another token
      const refName = value.slice(1, -1);
      return `var(--${convertToCssVarName(refName)})`;
    }
    return value;
  }
  return value;
}

/**
 * Generate CSS content from tokens
 */
function generateCSS() {
  const tokens = {};
  
  // Load all breakpoint token files
  for (const [breakpoint, config] of Object.entries(BREAKPOINTS)) {
    const filePath = path.join(__dirname, config.file);
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      tokens[breakpoint] = JSON.parse(content);
      console.log(`✓ Loaded ${config.file} (${breakpoint})`);
    } catch (error) {
      console.error(`✗ Error loading ${config.file}:`, error.message);
      process.exit(1);
    }
  }

  // Generate CSS
  let css = `/**
 * Consonant Design System Tokens
 * Auto-generated from design-tokens/*.tokens.json
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'npm run tokens:generate' to regenerate
 */

`;

  // Desktop (default) tokens
  css += `:root {\n`;
  css += `  /* Desktop tokens (900px+) */\n`;
  const desktopTokens = flattenTokens(tokens.desktop);
  for (const [name, value] of Object.entries(desktopTokens).sort()) {
    css += `  ${name}: ${value};\n`;
  }
  css += `}\n\n`;

  // Tablet tokens
  const tabletConfig = BREAKPOINTS.tablet;
  css += `@media (min-width: ${tabletConfig.minWidth}px) and (max-width: ${tabletConfig.maxWidth}px) {\n`;
  css += `  :root {\n`;
  css += `    /* Tablet tokens */\n`;
  const tabletTokens = flattenTokens(tokens.tablet);
  for (const [name, value] of Object.entries(tabletTokens).sort()) {
    if (desktopTokens[name] !== value) {
      css += `    ${name}: ${value};\n`;
    }
  }
  css += `  }\n`;
  css += `}\n\n`;

  // Mobile tokens
  const mobileConfig = BREAKPOINTS.mobile;
  css += `@media (max-width: ${mobileConfig.maxWidth}px) {\n`;
  css += `  :root {\n`;
  css += `    /* Mobile tokens */\n`;
  const mobileTokens = flattenTokens(tokens.mobile);
  for (const [name, value] of Object.entries(mobileTokens).sort()) {
    if (desktopTokens[name] !== value) {
      css += `    ${name}: ${value};\n`;
    }
  }
  css += `  }\n`;
  css += `}\n`;

  return css;
}

/**
 * Write CSS to output file
 */
function writeCSS() {
  const css = generateCSS();
  const outputPath = path.join(__dirname, '../styles/consonant.css');
  
  fs.writeFileSync(outputPath, css, 'utf8');
  console.log(`\n✓ Generated: ${outputPath}`);
  console.log(`  File size: ${(css.length / 1024).toFixed(2)} KB`);
  
  // Count variables
  const varCount = (css.match(/--[a-z0-9-]+:/g) || []).length;
  console.log(`  Variables: ${varCount}`);
}

// Run the generator
try {
  console.log('Generating CSS from design tokens...\n');
  writeCSS();
  console.log('\n✓ Done!');
} catch (error) {
  console.error('\n✗ Error:', error.message);
  process.exit(1);
}
